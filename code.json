{
  "/**": {},
  "*Submittedfor verification at BscScan.com on 2022-05-13": {},
  "*/": {},
  "pragma": "",
  "*@dev Interface of the ERC20 standard as defined in the EIP.": {},
  "interface": {},
  "*@dev Returns the amount of tokens in existence.": {},
  "function": {},
  "*@dev Returns the amount of tokens owned by `account`.": {},
  "*@dev Moves `amount` tokens from the caller's account to `to`.": {},
  "*": {},
  "*Returns a boolean value indicating whether the operation succeeded.": {},
  "*Emits a {Transfer} event.": {},
  "*@dev Returns the remaining number of tokens that `spender` will be": {},
  "*allowed to spend on behalf of `owner` through {transferFrom}. This is": {},
  "*zero by default.": {},
  "*This value changes when {approve} or {transferFrom} are called.": {},
  "*@dev Sets `amount` as the allowance of `spender` over the caller's tokens.": {},
  "*IMPORTANT: Beware that changing an allowance with this method brings the risk": {},
  "*that someone may use both the old and the new allowance by unfortunate": {},
  "*transaction ordering. One possible solution to mitigate this race": {},
  "*condition is to first reduce the spender's allowance to 0 and set the": {},
  "*desired value afterwards:": {},
  "*https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729": {},
  "*Emits an {Approval} event.": {},
  "*@dev Moves `amount` tokens from `from` to `to` using the": {},
  "*allowance mechanism. `amount` is then deducted from the caller's": {},
  "*allowance.": {},
  "address": [
    {}
  ],
  "uint256": {},
  ")external returns (bool);": {},
  "*@dev Emitted when `value` tokens are moved from one account (`from`) to": {},
  "*another (`to`).": {},
  "*Note that `value` may be zero.": {},
  "event": {},
  "*@dev Emitted when the allowance of a `spender` for an `owner` is set by": {},
  "*a call to {approve}. `value` is the new allowance.": {},
  "}": {},
  "*@dev Wrappers over Solidity's arithmetic operations.": {},
  "*NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler": {},
  "*now has built in overflow checking.": {},
  "library": "",
  "*@dev Returns the addition of two unsigned integers, with an overflow flag.": {},
  "*_Available since v3.4._": {},
  "unchecked{": {},
  "if(c < a) return (false, 0);": {},
  "return(true, c);": {},
  "*@dev Returns the substraction of two unsigned integers, with an overflow flag.": {},
  "if(b > a) return (false, 0);": {},
  "return(true, a - b);": {},
  "*@dev Returns the multiplication of two unsigned integers, with an overflow flag.": {},
  "if": "= address(uniswapV2Pair)){",
  "*@dev Returns the division of two unsigned integers, with a division by zero flag.": {},
  "return(true, a / b);": {},
  "*@dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.": {},
  "return(true, a % b);": {},
  "*@dev Returns the addition of two unsigned integers, reverting on": {},
  "*overflow.": {},
  "*Counterpart to Solidity's `+` operator.": {},
  "*Requirements:": {},
  "*- Addition cannot overflow.": {},
  "return": false,
  "*@dev Returns the subtraction of two unsigned integers, reverting on": {},
  "*overflow (when the result is negative).": {},
  "*Counterpart to Solidity's `-` operator.": {},
  "*- Subtraction cannot overflow.": {},
  "*@dev Returns the multiplication of two unsigned integers, reverting on": {},
  "*Counterpart to Solidity's `*` operator.": {},
  "*- Multiplication cannot overflow.": {},
  "*@dev Returns the integer division of two unsigned integers, reverting on": {},
  "*division by zero. The result is rounded towards zero.": {},
  "*Counterpart to Solidity's `/` operator.": {},
  "*- The divisor cannot be zero.": {},
  "*@dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),": {},
  "*reverting when dividing by zero.": {},
  "*Counterpart to Solidity's `%` operator. This function uses a `revert`": {},
  "*opcode (which leaves remaining gas untouched) while Solidity uses an": {},
  "*invalid opcode to revert (consuming all remaining gas).": {},
  "*@dev Returns the subtraction of two unsigned integers, reverting with custom message on": {},
  "*CAUTION: This function is deprecated because it requires allocating memory for the error": {},
  "*message unnecessarily. For custom revert reasons use {trySub}.": {},
  "string": {},
  ")internal pure returns (uint256) {": {},
  "require(b": "a, errorMessage);",
  "*@dev Returns the integer division of two unsigned integers, reverting with custom message on": {},
  "*Counterpart to Solidity's `/` operator. Note: this function uses a": {},
  "*`revert` opcode (which leaves remaining gas untouched) while Solidity": {},
  "*uses an invalid opcode to revert (consuming all remaining gas).": {},
  "require(b> 0, errorMessage);": {},
  "*reverting with custom message when dividing by zero.": {},
  "*message unnecessarily. For custom revert reasons use {tryMod}.": {},
  "*@dev Provides information about the current execution context, including the": {},
  "*sender of the transaction and its data. While these are generally available": {},
  "*via msg.sender and msg.data, they should not be accessed in such a direct": {},
  "*manner, since when dealing with meta-transactions the account sending and": {},
  "*paying for execution may not be the actual sender (as far as an application": {},
  "*is concerned).": {},
  "*This contract is only required for intermediate, library-like contracts.": {},
  "abstract": {},
  "*@dev Collection of functions related to the address type": {},
  "*@dev Returns true if `account` is a contract.": {},
  "*It is unsafe to assume that an address for which this function returns": {},
  "*false is an externally-owned account (EOA) and not a contract.": {},
  "*Among others, `isContract` will return false for the following": {},
  "*types of addresses:": {},
  "* - an externally-owned account": {},
  "* - a contract in construction": {},
  "* - an address where a contract will be created": {},
  "* - an address where a contract lived, but was destroyed": {},
  "*You shouldn't rely on `isContract` to protect against flash loan attacks!": {},
  "*Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets": {},
  "*like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract": {},
  "*constructor.": {},
  "*@dev Replacement for Solidity's `transfer`: sends `amount` wei to": {},
  "*`recipient`, forwarding all available gas and reverting on errors.": {},
  "*https://eips.ethereum.org/EIPS/eip-1884": {},
  "*of certain opcodes, possibly making contracts go over the 2300 gas limit": {},
  "*imposed by `transfer`, making them unable to receive funds via": {},
  "*`transfer`. {sendValue} removes this limitation.": {},
  "*https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/": {},
  "*IMPORTANT: because control is transferred to `recipient`, care must be": {},
  "*taken to not create reentrancy vulnerabilities. Consider using": {},
  "*{ReentrancyGuard} or the": {},
  "*https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern": {},
  "require(address(this).balance": "value, \"Address: insufficient balance for call\");",
  "(bool": "target.call{value: value}(data);",
  "require(success,\"Address: unable to send value, recipient may have reverted\");": {},
  "*@dev Performs a Solidity function call using a low level `call`. A": {},
  "*plain `call` is an unsafe replacement for a function call: use this": {},
  "*function instead.": {},
  "*If `target` reverts with a revert reason, it is bubbled up by this": {},
  "*function (like regular Solidity function calls).": {},
  "*Returns the raw returned data. To convert to the expected return value,": {},
  "*- `target` must be a contract.": {},
  "*- calling `target` with `data` must not revert.": {},
  "*_Available since v3.1._": {},
  "*@dev Same as {xref-Address-functionCall-address-bytes-}": {},
  "*`errorMessage` as a fallback revert reason when `target` reverts.": {},
  "bytes": {},
  ")internal returns (bytes memory) {": {},
  "*but also transferring `value` wei to `target`.": {},
  "*- the calling contract must have an ETH balance of at least `value`.": {},
  "*- the called Solidity function must be `payable`.": {},
  "*@dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}": {},
  "*with `errorMessage` as a fallback revert reason when `target` reverts.": {},
  "require(isContract(target),\"Address: call to non-contract\");": {},
  "*but performing a static call.": {},
  "*_Available since v3.3._": {},
  "*@dev Same as {xref-Address-functionCall-address-bytes-string-}": {},
  ")internal view returns (bytes memory) {": {},
  "require(isContract(target),\"Address: static call to non-contract\");": {},
  "*but performing a delegate call.": {},
  "require(isContract(target),\"Address: delegate call to non-contract\");": {},
  "*@dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the": {},
  "*revert reason using the provided one.": {},
  "*_Available since v4.3._": {},
  "bool": {},
  ")internal pure returns (bytes memory) {": {},
  "if(success) {": {},
  "}else {": {},
  "if(returndata.length > 0) {": {},
  "assembly{": {},
  "let": {},
  "revert(add(32,returndata), returndata_size)": {},
  "revert(errorMessage);": {},
  "*@dev Contract module which provides a basic access control mechanism, where": {},
  "*there is an account (an owner) that can be granted exclusive access to": {},
  "*specific functions.": {},
  "*By default, the owner account will be the one that deploys the contract. This": {},
  "*can later be changed with {transferOwnership}.": {},
  "*This module is used through inheritance. It will make available the modifier": {},
  "*`onlyOwner`, which can be applied to your functions to restrict their use to": {},
  "*the owner.": {},
  "*@dev Initializes the contract setting the deployer as the initial owner.": {},
  "constructor(){": {},
  "_transferOwnership(_msgSender());": {},
  "*@dev Returns the address of the current owner.": {},
  "*@dev Throws if called by any account other than the owner.": {},
  "modifier": {},
  "require(owner()": "= _msgSender(), \"Ownable: caller is not the owner\");",
  "_;": {},
  "*@dev Leaves the contract without owner. It will not be possible to call": {},
  "*`onlyOwner` functions anymore. Can only be called by the current owner.": {},
  "*NOTE: Renouncing ownership will leave the contract without an owner,": {},
  "*thereby removing any functionality that is only available to the owner.": {},
  "_transferOwnership(address(0));": {},
  "*@dev Transfers ownership of the contract to a new account (`newOwner`).": {},
  "*Can only be called by the current owner.": {},
  "require(newOwner": "address(0), \"Ownable: new owner is the zero address\");",
  "_transferOwnership(newOwner);": {},
  "*Internal function without access restriction.": {},
  "_owner": "newOwner;",
  "emit": "",
  "uint": {},
  ");": {},
  ")external returns (uint amountA, uint amountB, uint liquidity);": {},
  ")external payable returns (uint amountToken, uint amountETH, uint liquidity);": {},
  ")external returns (uint amountA, uint amountB);": {},
  ")external returns (uint amountToken, uint amountETH);": {},
  ")external returns (uint memory amounts);": [],
  "external": {},
  "payable": {},
  "returns(uint memory amounts);": [],
  ")external returns (uint amountETH);": {},
  ")external;": {},
  ")external payable;": {},
  "contract": "2022-06-26T03:46:43.653Z",
  "using": "",
  "": {},
  "mapping": "> uint256) private _rOwned;",
  "uint8": {},
  "IUniswapV2Router02": {},
  "inSwapAndLiquify": "true;",
  "constructor(address tokenOwner,string memory name_, string memory symbol_,uint8 decimal_, uint256 amountOfTokenWei,uint8 memory setFees, uint256": [
    {}
  ],
  "_name": "name_;",
  "_symbol": "symbol_;",
  "_decimals": "decimal_;",
  "_tTotal": "amountOfTokenWei;",
  "_rTotal": "_rTotal.sub(rAmount);",
  "router": "_router;",
  "basePair": "_basePair;",
  "_rOwned": "_rOwned[sender].sub(rAmount);",
  "maxTaxFee": [
    "maxFees[0];"
  ],
  "maxLiqFee": [
    [
      "maxFees[1];"
    ]
  ],
  "maxDevFee": [
    [
      "maxFees[2];"
    ]
  ],
  "minMxTxPercentage": [
    [
      "maxFees[3];"
    ]
  ],
  "maxSellTaxFee": [
    [
      "maxFees[4];"
    ]
  ],
  "_taxFee": "taxFee;",
  "_previousTaxFee": "_taxFee;",
  "_liquidityFee": "liquidityFee;",
  "_previousLiquidityFee": "_liquidityFee;",
  "_devFee": "devFee;",
  "_previousDevFee": "_devFee;",
  "_sellTaxFee": "sellTaxFee;",
  "_previousSellFee": "_sellTaxFee;",
  "_devWalletAddress": "_addr;",
  "_maxTxAmount": "_tTotal.mul(maxTxPercent).div(",
  "numTokensSellToAddToLiquidity": "amountOfTokenWei.mul(1).div(1000);",
  "uniswapV2Pair": "UniSwapFactory(_uniswapV2Router.factory())",
  ".createPair(address(this),basePair);": {},
  "uniswapV2Router": "_uniswapV2Router;",
  "_isExcludedFromFee": "true;",
  "_isdevWallet": "true;",
  "if(_isExcluded": {},
  "_transfer(_msgSender(),recipient, amount);": {},
  "_approve(_msgSender(),spender, amount);": {},
  "_transfer(sender,recipient, amount);": {},
  "_approve(sender,_msgSender(), _allowances": {},
  "_approve(_msgSender(),spender, _allowances": {},
  "require(!_isExcluded": {},
  "(uint256": "_getValues(tAmount);",
  "_tFeeTotal": "_tFeeTotal.add(tAmount);",
  "require(tAmount": "_tTotal, \"Amount must be less than supply\");",
  "if(!deductTransferFee) {": {},
  "(,uint256": "_getValues(tAmount);",
  "require(rAmount": "_rTotal, \"Amount must be less than total reflections\");",
  "require(!_isExcludedFromFee": {},
  "require(_isExcludedFromFee": {},
  "require(taxFee": "0 && taxFee <=maxTaxFee,\"taxFee out of range\");",
  "require(liquidityFee": "0 && liquidityFee <=maxLiqFee,\"liquidityFee out of range\");",
  "require(devFee": "0 && devFee <=maxDevFee,\"teamFee out of range\");",
  "require(sellTaxFee": "0 && sellTaxFee <=maxSellTaxFee,\"taxFee out of range\");",
  "require(maxTxPercent": "minMxTxPercentage && maxTxPercent <=100,\"maxTxPercent out of range\");",
  "10**2": {},
  "require(!_isdevWallet": {},
  "if(!_isExcludedFromFee": {},
  "excludeFromFee(_addr);": {},
  "require(_isdevWallet": {},
  "if(_isExcludedFromFee": {},
  "includeInFee(_addr);": {},
  "setDevWalletAddress(_newAddr);": {},
  "swapAndLiquifyEnabled": "_enabled;",
  "return(rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tLiquidity, tDev);": {},
  "return(tTransferAmount, tFee, tLiquidity, tDev);": {},
  "return(rAmount, rTransferAmount, rFee);": {},
  "for": "0; i < _excluded.length; i++) {",
  "if(_rOwned": {},
  "rSupply": "rSupply.sub(_rOwned[_excluded[i]]);",
  "tSupply": "tSupply.sub(_tOwned[_excluded[i]]);",
  "if(rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);": {},
  "return(rSupply, tSupply);": {},
  "_tOwned": "_tOwned[recipient].add(tTransferAmount);",
  "if(_taxFee": "= 0 && _liquidityFee == 0 && _devFee == 0) return;",
  "require(owner": "address(0), \"ERC20: approve from the zero address\");",
  "require(spender": "address(0), \"ERC20: approve to the zero address\");",
  "_allowances": "amount;",
  "require(from": "address(0), \"ERC20: transfer from the zero address\");",
  "require(to": "address(0), \"ERC20: transfer to the zero address\");",
  "require(amount> 0, \"Transfer amount must be greater than zero\");": {},
  "if(from": "owner() && to != owner())",
  "require(amount": "_maxTxAmount, \"Transfer amount exceeds the maxTxAmount.\");",
  "if(contractTokenBalance": "_maxTxAmount)",
  "{": {},
  "contractTokenBalance": "numTokensSellToAddToLiquidity;",
  "if(": {},
  "overMinTokenBalance&&": {},
  "!inSwapAndLiquify&&": {},
  "from": "uniswapV2Pair &&",
  "){": {},
  "swapAndLiquify(contractTokenBalance);": {},
  "takeFee": "false;",
  "_tokenTransfer(from,to,amount,takeFee);": {},
  "restoreAllFee();": {},
  "addLiquidity(otherHalf,newBalance);": {},
  "path": [
    "address(this);",
    [
      "getWrapAddr();"
    ]
  ],
  "_approve(address(this),address(uniswapV2Router), tokenAmount);": {},
  "try": {},
  "tokenAmount,": {},
  "0,// accept any amount of ETH": {},
  "path,": {},
  "address(this),": {},
  "block.timestamp": {},
  "){}": {},
  "catch(bytesmemory) {": {},
  "uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(": {},
  "0,// slippage is unavoidable": {},
  "dead,": {},
  "catch(bytes memory) {": {},
  "uniswapV2Router.addLiquidityETH{value: ETHAmount}(": {},
  "if(!takeFee)": {},
  "removeAllFee();": {},
  "_transferFromExcluded(sender,recipient, amount);": {},
  "}else if (!_isExcluded": {},
  "_transferToExcluded(sender,recipient, amount);": {},
  "_transferStandard(sender,recipient, amount);": {},
  "}else if (_isExcluded": {},
  "_transferBothExcluded(sender,recipient, amount);": {},
  "_takeLiquidity(tLiquidity);": {},
  "_takeDev(tDev);": {},
  "_reflectFee(rFee,tFee);": {},
  "prevLiqFee": "_liquidityFee;",
  "prevTaxFee": "_taxFee;",
  "prevDevFee": "_devFee;",
  "prevSellFee": "_sellTaxFee;"
}